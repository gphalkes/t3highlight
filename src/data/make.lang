format = 1

%define {
	functions {
		%pattern {
			regex = '(?<=\$[{(])(?:patsubst|subst|strip|findstring|filter(?:-out)|' +
				'sort|word|wordlist|words|firstword|lastword|dir|notdir|suffix|' +
				'basename|addsuffix|addprefix|join|wildcard|realpath|abspath|' +
				'if|or|and|foreach|call|value|eval|origin|flavor|error|warning|' +
				'info)\b'
			style = "misc"
		}
	}
	variable {
		%pattern {
			start = '\$\{'
			%pattern { use = "variable" }
			%pattern { use = "functions" }
			end = '\}'
			style = "variable"
		}
		%pattern {
			start = '\$\('
			%pattern { use = "variable" }
			%pattern { use = "functions" }
			end = '\)'
			style = "variable"
		}
		%pattern {
			regex = '\$\$'
		}
	}
	comment {
		%pattern {
			start = '#'
			end = '(?<!\\)$'
			style = "comment"
		}
	}
	shell {
		# FIXME: Here we need to build the shell language. Simply including sh.lang
		# is not going to work, because escaping of the dollar character is
		# required. However, we can probably get away with a simpler version of the
		# shell stuff, because if it gets complicated you probably want to put it
		# in a proper script anyway.

		# Another complication is that commands are terminated at the end of line,
		# unless a \ preceeds the newline. This is different from the normal shell
		# matching behaviour, where most environments span newlines.
		%pattern { use = "variable" }
		%pattern { use = "comment" }
	}
}

%pattern { use = "variable" }
%pattern { use = "comment" }
%pattern {
	start = '^\t'
	%pattern { use = "shell" }
	end = '(?<!\\)$'
}
%pattern {
	start = '[:+?]?='
	%pattern { use = "variable" }
	%pattern { use = "comment" }
	end = '(?<!\\)$'
}
# BSD make also uses != as shell expansion
%pattern {
	start = '!='
	%pattern { use = "shell" }
	end = '(?<!\\)$'
}
%pattern {
	# BSD make also uses ! as rule separator
	start = '::?|!'
	%pattern {
		start = ';'
		%pattern { use = "shell" }
		end = '(?<!\\)$'
	}
	%pattern { use = "variable" }
	%pattern { use = "comment" }
	end = '(?<!\\)$|#'
}
# GNU make directives
%pattern {
	start = '^ *\K(?:-?include|ifn?(:?def|eq)|else|endif)\b'
	%pattern { use = "variable" }
	%pattern { use = "comment" }
	end = '(?<!\\)$'
	delim-style = "keyword"
}
%pattern {
	start = '^ *\K\.(?:s?include|undef|error|warning|if(?:n?(?:def|make))|elif(?:n?(?:def|make))?|else)\b'
	%pattern { use = "variable" }
	%pattern { use = "comment" }
	end = '(?<!\\)$'
	delim-style = "keyword"
}

# This pattern colors all line beginnings. All assignments and rules will stop
# coloring after the operator, due to the patterns above
%pattern {
	regex = '[^ ]'
	style = 'string'
}
